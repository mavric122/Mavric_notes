ListView и общая информация
Пример:
Рекомендуется для списочных данных(меню, категории, списки товаров)
class GetCategory(ListView):
 model = Tovar
 template_name = 'tovar/list_tovar.html'
 context_object_name = 'tovar'
 extra_context = {'title': 'Категория'}

 def get_context_data(self, **kwargs):
 context = super().get_context_data(**kwargs)
 context['title'] = Category.objects.get(pk=self.kwargs['category_id'])
 return context

 def get_queryset(self):
 return Tovar.objects.filter(category_id=self.kwargs['category_id'])

Основной класс
1) model = Tovar  тоже самое что — Tovar.objects.all(). Выгружаем все данные модели
2) template_name = 'tovar/list_tovar.html' -   присваиваем путь к нужному шаблону
3) context_object_name = 'tovar'  Изначально все данные из пункта 1 помещаются в коллекцию «object_list» и если мы ее запишем вместо tovar, то должно все заработать. Если в шаблоне  мы хотим использовать другое обозначение (имя), то в классе  следует прописать атрибут context_object_name с указанием другого имени переменной, как в примере выше.
4) extra_context = {'title': 'Категория'} Для передачи шаблону статичных данных, можно использовать специальный словарь extra_context.Но, обратите внимание, этот словарь можно использовать именно для статичных (не изменяемых) данных, такие как строки, числа.
 def get_context_data(self, **kwargs):

Если мы собираемся передавать динамические данные, вроде списков, то для этого уже нужно переопределять метод get_context_data базового класса. 

context = super().get_context_data(**kwargs)

Здесь super() – это обращение к базовому классу и, далее, через точку, идет вызов аналогичного метода с передачей ему возможных именованных параметров из словаря kwargs. Сформированный базовый контекст мы сохраняем через переменную context.
В действительности, переменная context ссылается на словарь и, если нам нужно добавить какой-либо ключ, или изменить уже существующий, то достаточно записать:
context['title'] = Category.objects.get(pk=self.kwargs['category_id'])
context['title'] = 'Главная страница'

В конце обязательно 
 return context

Тогда мы взяли и в значение ['title'] положили всю категорию. Теперь можем вывести в шаблоне  её номер titel.pk



def get_queryset(self):
Фильтрация переданных моделей по определённому флагу
Например по определённой категории.
 return Tovar.objects.filter(category_id=self.kwargs['category_id'])
Или только опубликованные статьи
return Women.objects.filter(is_published=True)
Или и то и то через запятую
return Tovar.objects.filter(category_id=self.kwargs['category_id'], is_published=True)

allow_empty = False

указывает генерировать исключение 404 если список статей пуст. 

------------------------------------------------------------------------------------------------------------------------------------

Использование класса DetailView
Рекомендуется для одиночных постов данных.
Пример:
class ViewTovar(DeleteView):
    model = Tovar
    template_name = 'tovar/tovar_id.html'
    context_object_name = 'tovar'
    pk_url_kwarg = 'tovar_id'

В url примерно так:
path('tovar/id/<int:tovar_id>', ViewTovar.as_view(), name='view_tovar'),



def get_context_data(self, **kwargs, ):
    context = super().get_context_data(**kwargs)
    context['tovar'] = Tovar.objects.get(id=self.kwargs['tovar_id'])
    context['history'] = Tovar.history.filter(id=self.kwargs['tovar_id'])
    return context

при попытке просмотра какого-либо поста, возникает исключение «AttributeError». В чем проблема? Смотрите, вот этот класс DetailView по умолчанию пытается выбрать из указанной модели Tovar запись, используя атрибут pk или slug. Но у нас формируется маршрут с параметром post_slug из-за этого и возникает такая ошибка.
В самом простом случае, мы можем в шаблоне маршрута вместо post_slug записать просто slug и тогда ошибки уже не будет. Или же, в классе ShowPost прописать атрибут:
slug_url_kwarg = 'post_slug'
(Если используется идентификатор, то прописывается атрибут pk_url_kwarg). Обычно, эти атрибуты опускают и в параметрах маршрутов используют ключевые слова slug – для слага и pk – для идентификаторов.


В шаблоне через {{ tovar.что_нам из него нужно }} мы получаем данные конкретного товара по его id(pk) 

------------------------------------------------------------------------------------------------------------------------------------

Использование класса CreateView
Класс для оптимизации работы с формами. Фактически, все что нам нужно сделать – это прописать в дочернем классе два атрибута:
class AddPage(CreateView):
    form_class = AddPostForm
    template_name = 'women/addpage.html'
Атрибут form_class связывает представление с классом формы AddPostForm, а template_name задает шаблон отображения формы. Если теперь связать маршрут с нашим новым представлением:
path('addpage/', AddPage.as_view(), name='add_page'),

то мы увидим полноценную форму со всем необходимым функционалом. Единственное, что нужно еще добавить – это отображение главного меню и заголовка (в классе AddPage):

 def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = 'Добавление статьи'
        context['menu'] = menu
        return context
Все, работа с формой готова! Проще не придумаешь. Давайте добавим что-нибудь и при нажатии на кнопку «Добавить» мы автоматически переходим к отображению этой записи. Как это сработало? Откуда класс CreateView «узнал» куда нас следует перенаправить? Этот функционал реализуется благодаря наличию метода get_absolute_url в модели Women. Класс CreateView обращается к этому методу для получения URL-адреса добавленной статьи и перенаправляет нас к ней. Видите, как полезно следовать конвенции Django и определять стандартные методы.
Но что делать, если по каким-либо причинам в модели нет метода get_absolute_url? Для этого в классе используется AddPage нужно прописать атрибут:
success_url = reverse_lazy('home')
В этом атрибуте мы можем указать конкретную строку с URL-адресом. Но это будет хардкод. Поэтому, используется функция reverse_lazy для построения маршрутов по их именам.
Почему мы здесь вызываем именно reverse_lazy, а не просто reverse? Дело в том, что функция reverse сразу пытается построить нужный маршрут в момент создания экземпляра класса. Но это сделать невозможно, т.к. маршруты еще не были сформированы самим Django. А вот функция reverse_lazy выполняет построение маршрута только в момент, когда он понадобится. Тогда маршруты уже будут существовать и никаких проблем не возникнет.
Вообще, чтобы не запутаться в таких нюансах, можно почти всегда использовать reverse_lazy вместо reverse. На первых порах это будет безопаснее.

------------------------------------------------------------------------------------------------------------------------------------

UpdateView

Основное отличие класса UpdateView от CreateView, это передача экземпляра изменяемого объекта атрибуту object данного класса, в остальном данные классы идентичны. Для редактирования нам достаточно передать в url первичный ключ или slug изменяемого объекта:
class ItemUpdate(UpdateView): 
form_class = ItemForm 
model = Item 
template_name = 'create_item.html' 
pk_url_kwarg = 'pk'
success_url = '/success/'

Всё нам знакомо кроме: 
success_url = '/success/'
Это куда сделат перенаправление в случае успеха обновления модели.

Если нужно сделать перенаправление на путь с параметрами подойдёт такой вариант:

def get_success_url(self):
    pk = self.kwargs["pk"]
    return reverse_lazy("view_tovar", kwargs={"tovar_id": pk})

------------------------------------------------------------------------------------------------------------------------------------

DeleteView